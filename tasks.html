<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Мои задачи</title>
   <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    
    <link rel="stylesheet" href="styles.css">
</head>
<body class="tasks-page"> 
    </body>
    <div class="container"> <div id="topBar">
            <span id="userNameDisplay"></span> <a href="index.html" onclick="logout()" class="logout-link-top">Выйти</a>
        </div>

        <div class="main-header">
           <a href="create-task.html" class="create-task-button">Новая Задача +</a>
            <h1>Мои задачи</h1>
        </div>

<div class="filter-buttons">
    <button class="filter-button active" data-filter="all">Все активные</button>
    <button class="filter-button" data-filter="inprogress">В работе</button> 
    <button class="filter-button" data-filter="oncheck">На проверке</button>
    <button class="filter-button" data-filter="completed">Выполненные</button>
</div>
                
        <div id="loadingMessage" style="display: none;">Загрузка задач...</div>
        <div id="errorMessage" class="error-message" style="display: none;"></div>
        <ul id="taskListContainer" class="task-list">
            </ul>
        <div id="paginationControls" class="pagination-controls-container" style="display: none;">
            </div>
        <div id="noTasksMessage" style="display: none;">У вас пока нет задач.</div>

        </div> 

<script>
    let tasksUpdateIntervalId = null;
    const TASKS_UPDATE_INTERVAL = 20000; 
    let currentStatusFilter = 'all'; 
    
    // Новые переменные для пагинации списка "Выполненные"
    let currentPageForCompleted = 1;
    const PAGE_SIZE_FOR_COMPLETED = 10; // Например, 10 задач на странице
    let totalPagesForCompleted = 0;

    function escapeHTML(str) {
        if (typeof str !== 'string') return '';
        const div = document.createElement('div');
        div.appendChild(document.createTextNode(str));
        return div.innerHTML;
    }

    window.onload = function() {
        const userName = localStorage.getItem('userName');
        const userCode = localStorage.getItem('userCode');
        
        const userNameDisplaySpan = document.getElementById('userNameDisplay');

        if (userNameDisplaySpan && userName) {
            userNameDisplaySpan.innerHTML = `Пользователь: <strong>${escapeHTML(userName)}</strong>`; // Добавлено escapeHTML
        }

        if (!userCode) {
            if (tasksUpdateIntervalId) clearInterval(tasksUpdateIntervalId);
            window.location.href = 'index.html'; 
            return;
        }
        
        // При первоначальной загрузке сбрасываем страницу для "Выполненных" на 1
        currentPageForCompleted = 1; 
        loadTasks(userCode, false, currentStatusFilter, currentPageForCompleted); 
        setupFilterButtons(userCode); 

        if (tasksUpdateIntervalId) clearInterval(tasksUpdateIntervalId); 
        tasksUpdateIntervalId = setInterval(() => {
            // Для автообновления всегда загружаем текущую страницу
            // Если это "completed", то currentPageForCompleted, иначе - не используется (сервер вернет все)
            const pageToLoad = (currentStatusFilter === 'completed') ? currentPageForCompleted : 1;
            loadTasks(userCode, true, currentStatusFilter, pageToLoad); 
        }, TASKS_UPDATE_INTERVAL);
    };

    function updateFilterButtonIndicators(newInCategoriesData) {
        const filterButtons = document.querySelectorAll('.filter-button');
        // console.log("Данные для индикаторов:", newInCategoriesData); 
        filterButtons.forEach(button => {
            const filterKey = button.dataset.filter;
            // console.log(`Кнопка: ${filterKey}, Новое: ${newInCategoriesData ? newInCategoriesData[filterKey] : 'нет данных'}`); 
            if (newInCategoriesData && newInCategoriesData[filterKey] === true) {
                button.classList.add('has-new-items');
                // console.log(`   -> Добавлен класс has-new-items для ${filterKey}`);
            } else {
                button.classList.remove('has-new-items');
            }
        });
    }

    function setupFilterButtons(userCode) {
        const filterButtons = document.querySelectorAll('.filter-button');
        filterButtons.forEach(button => {
            button.addEventListener('click', function() {
                filterButtons.forEach(btn => btn.classList.remove('active'));
                this.classList.add('active');
                
                currentStatusFilter = this.dataset.filter;
                currentPageForCompleted = 1; // Сброс на первую страницу при смене фильтра
                
                this.classList.remove('has-new-items'); 

                if (tasksUpdateIntervalId) clearInterval(tasksUpdateIntervalId);
                
                loadTasks(userCode, false, currentStatusFilter, currentPageForCompleted); 
                
                tasksUpdateIntervalId = setInterval(() => {
                    const pageToLoad = (currentStatusFilter === 'completed') ? currentPageForCompleted : 1;
                    loadTasks(userCode, true, currentStatusFilter, pageToLoad);
                }, TASKS_UPDATE_INTERVAL);
            });
        });
    }

    async function loadTasks(userCode, isPollingUpdate = false, statusFilter = 'all', page = 1) {
        const loadingMessageDiv = document.getElementById('loadingMessage');
        const errorMessageDiv = document.getElementById('errorMessage');
        const taskListContainer = document.getElementById('taskListContainer');
        const noTasksMessageDiv = document.getElementById('noTasksMessage');
        const paginationControlsDiv = document.getElementById('paginationControls'); // Получаем контейнер пагинации

        if (!isPollingUpdate) { 
            if (loadingMessageDiv) loadingMessageDiv.style.display = 'block';
            if (noTasksMessageDiv) noTasksMessageDiv.style.display = 'none';
            if (taskListContainer) taskListContainer.innerHTML = ''; 
            if (errorMessageDiv) errorMessageDiv.style.display = 'none';
            if (paginationControlsDiv) paginationControlsDiv.innerHTML = ''; // Очищаем кнопки пагинации
            if (paginationControlsDiv) paginationControlsDiv.style.display = 'none'; // Скрываем пагинацию
        } else {
            if (errorMessageDiv) errorMessageDiv.style.display = 'none';
        }

        let apiUrl = `https://1c.c-r.kz/Registrator_test/hs/auth/taskslist/${userCode}`;
        const params = new URLSearchParams();

        if (statusFilter && statusFilter !== 'all') {
            params.append('statusFilter', statusFilter);
        }

        // Добавляем параметры пагинации, только если фильтр "completed"
        if (statusFilter === 'completed') {
            params.append('page', page);
            params.append('pageSize', PAGE_SIZE_FOR_COMPLETED);
        }
        
        if (Array.from(params).length > 0) {
            apiUrl += `?${params.toString()}`;
        }
        
        try {
            const response = await fetch(apiUrl, { method: 'GET' });

            if (!isPollingUpdate && loadingMessageDiv) {
                loadingMessageDiv.style.display = 'none';
            }

            if (!response.ok) {
                let errorMsg = `Ошибка загрузки задач: ${response.status} ${response.statusText}`;
                try {
                    const errorData = await response.json();
                    if (errorData && errorData.message) { errorMsg += ` - ${errorData.message}`; }
                } catch (e) { /* Не JSON */ }
                if (!isPollingUpdate && errorMessageDiv) { 
                    errorMessageDiv.textContent = errorMsg;
                    errorMessageDiv.style.display = 'block';
                }
                return; 
            }

            const result = await response.json(); 
            // console.log("Ответ от сервера:", result); // Для отладки данных пагинации

            if (result && result.success) {
                if (result.tasks && result.tasks.length > 0) {
                    if (noTasksMessageDiv) noTasksMessageDiv.style.display = 'none';
                    displayTasks(result.tasks); 
                } else {
                    if (!isPollingUpdate || statusFilter !== 'completed') { // Очищаем, только если не пагинация или не "completed"
                        if (taskListContainer) taskListContainer.innerHTML = ''; 
                    }
                     // Для пагинации, если задач на странице нет, но есть другие страницы, "нет задач" не показываем
                    if (statusFilter !== 'completed' || (statusFilter === 'completed' && (!result.totalPages || result.totalPages === 0))) {
                       if (noTasksMessageDiv) noTasksMessageDiv.style.display = 'block';
                    }
                }
                
                if (result.newInCategories) {
                    updateFilterButtonIndicators(result.newInCategories);
                } else {
                    updateFilterButtonIndicators({}); 
                }

                // Обработка данных пагинации для "completed"
                if (statusFilter === 'completed') {
                    currentPageForCompleted = result.currentPage || 1;
                    totalPagesForCompleted = result.totalPages || 0;
                    // console.log(`Pagination: Current: ${currentPageForCompleted}, Total: ${totalPagesForCompleted}, TotalTasks: ${result.totalTasks}`);
                    renderPaginationControls(userCode); // Передаем userCode для использования в обработчиках
                } else {
                    if (paginationControlsDiv) paginationControlsDiv.style.display = 'none'; // Скрываем пагинацию для других фильтров
                }

            } else {
                 if (!isPollingUpdate && errorMessageDiv) {
                    errorMessageDiv.textContent = (result && result.message) || "Получен некорректный ответ от сервера.";
                    errorMessageDiv.style.display = 'block';
                }
            }
        } catch (error) {
            if (!isPollingUpdate && loadingMessageDiv) { loadingMessageDiv.style.display = 'none'; }
            if (!isPollingUpdate && errorMessageDiv) { 
                errorMessageDiv.textContent = 'Сетевая ошибка: ' + error.message;
                errorMessageDiv.style.display = 'block';
            }
        }
    }

    function displayTasks(tasks) {
        const taskListContainer = document.getElementById('taskListContainer');
        if (!taskListContainer) {
            return;
        }
        // Если это НЕ пагинация для "completed", то очищаем контейнер.
        // При пагинации "completed" мы не очищаем, если это "load more" (пока не load more, но логика схожа)
        // В текущей реализации с перерисовкой страницы - всегда очищаем, если это не фоновое обновление.
        // Поскольку loadTasks уже очищает контейнер при !isPollingUpdate, здесь доп. очистка не нужна.
        // НО, если мы решим делать "дозагрузку", то очищать не нужно будет. Сейчас - очищаем всегда перед отрисовкой новой страницы.
        taskListContainer.innerHTML = ''; 


        tasks.forEach(task => {
            const listItem = document.createElement('li');
            listItem.className = 'task-item';

            if (task.hasUnreadByEmployee) {
                listItem.classList.add('has-unread-messages');
            }

            let originalStatusFromServer = String(task.status || '').trim(); 
            let displayStatusText = escapeHTML(originalStatusFromServer) || 'Статус не определен'; // escapeHTML
            
            if (originalStatusFromServer.toLowerCase().replace(/\s+/g, '') === "требуетоценки") {
                displayStatusText = 'Передано на оценку';
            }
            
            let statusClass = 'status-default';
            if (originalStatusFromServer) {
                const statusNormalized = originalStatusFromServer.toLowerCase().replace(/\s+/g, '-');
                if (statusNormalized.includes('новая')) statusClass = 'status-new';
                else if (statusNormalized.includes('в-работе')) statusClass = 'status-in-progress';
                else if (statusNormalized.includes('на-проверке')) statusClass = 'status-on-check';
                else if (statusNormalized.includes('выполнена') || statusNormalized.includes('закрыта')) statusClass = 'status-completed';
                else if (statusNormalized.includes('оценкасогласована') || statusNormalized.includes('оценка-согласована')) statusClass = 'status-согласование-оценки';
                else if (originalStatusFromServer.toLowerCase().replace(/\s+/g, '') === "требуетоценки") { 
                    statusClass = 'status-awaiting-assessment'; 
                } else if (statusNormalized.includes('требуетоценки')) { // Добавлено для случая "ТребуетОценки" без пробелов
                    statusClass = 'status-awaiting-assessment';
                    displayStatusText = 'Передано на оценку';
                }
            }
            
            let formattedDate = task.date;
            if (task.date) {
                try {
                    let dateObj = new Date(task.date);
                    if (isNaN(dateObj.getTime())) {
                        // Попытка исправить дату без 'Т' если она в формате "гггг-ММ-дд ЧЧ:мм:сс"
                        const parts = task.date.split(' ');
                        if (parts.length === 2) {
                           dateObj = new Date(parts[0] + 'T' + parts[1]);
                        }
                         // Если все еще невалидна, пробуем "гггг.ММ.дд ЧЧ:мм:сс" -> "гггг-ММ-ддТЧЧ:мм:сс"
                        if (isNaN(dateObj.getTime()) && task.date.includes('.')) {
                            dateObj = new Date(task.date.replace(/\./g, '-').replace(' ', 'T'));
                        }
                    }

                    if (!isNaN(dateObj.getTime())) {
                        formattedDate = dateObj.toLocaleString('ru-RU', {
                            year: 'numeric', month: '2-digit', day: '2-digit', // Используем 2-digit для месяца и дня
                            hour: '2-digit', minute: '2-digit'
                        }).replace(/, /g, ' '); // Заменяем ", " между датой и временем на пробел
                    } else { formattedDate = "Некорректная дата"; }
                } catch (e) { formattedDate = escapeHTML(task.date) + " (ошибка формата)"; }
            } else {
                formattedDate = 'не указана';
            }

            let taskHTML = '<div class="task-info">';
            taskHTML += '<h3>' + (escapeHTML(task.summary) || 'Без темы') + ' (№' + (escapeHTML(task.number) || 'б/н') + ')</h3>';
            taskHTML += '<p>Дата: ' + formattedDate + '</p>';
            taskHTML += '</div>'; 
            taskHTML += '<div class="unread-indicator-container"><span class="unread-indicator"></span></div>';
            taskHTML += '<span class="task-status ' + statusClass + '">' + displayStatusText + '</span>'; // displayStatusText уже содержит escapeHTML
            listItem.innerHTML = taskHTML;
            
            listItem.onclick = function() {
                if (tasksUpdateIntervalId) clearInterval(tasksUpdateIntervalId);
                localStorage.setItem('currentTaskId', task.id);
                localStorage.setItem('currentTaskNumber', task.number);
                window.location.href = 'task-details.html';
            };

            listItem.style.cursor = 'pointer';
            taskListContainer.appendChild(listItem);
        });
    }

    // Новая функция для отрисовки кнопок пагинации
    function renderPaginationControls(userCode) {
        const paginationControlsDiv = document.getElementById('paginationControls');
        if (!paginationControlsDiv) return;

        paginationControlsDiv.innerHTML = ''; // Очищаем старые кнопки

        if (currentStatusFilter === 'completed' && totalPagesForCompleted > 1) {
            const prevButton = document.createElement('button');
            prevButton.textContent = 'Назад';
            prevButton.className = 'pagination-button';
            prevButton.disabled = currentPageForCompleted <= 1;
            prevButton.addEventListener('click', () => {
                if (currentPageForCompleted > 1) {
                    currentPageForCompleted--;
                    loadTasks(userCode, false, currentStatusFilter, currentPageForCompleted);
                }
            });

            const pageInfo = document.createElement('span');
            pageInfo.textContent = `Стр. ${currentPageForCompleted} из ${totalPagesForCompleted}`;
            pageInfo.className = 'pagination-info';

            const nextButton = document.createElement('button');
            nextButton.textContent = 'Вперед';
            nextButton.className = 'pagination-button';
            nextButton.disabled = currentPageForCompleted >= totalPagesForCompleted;
            nextButton.addEventListener('click', () => {
                if (currentPageForCompleted < totalPagesForCompleted) {
                    currentPageForCompleted++;
                    loadTasks(userCode, false, currentStatusFilter, currentPageForCompleted);
                }
            });

            paginationControlsDiv.appendChild(prevButton);
            paginationControlsDiv.appendChild(pageInfo);
            paginationControlsDiv.appendChild(nextButton);
            paginationControlsDiv.style.display = 'flex'; // Показываем блок
        } else {
            paginationControlsDiv.style.display = 'none'; // Скрываем, если не нужно
        }
    }


    function logout() {
        if (tasksUpdateIntervalId) clearInterval(tasksUpdateIntervalId);
        localStorage.removeItem('userName');
        localStorage.removeItem('userId');
        localStorage.removeItem('userCode');
        // Добавим также сброс состояний пагинации при выходе
        currentPageForCompleted = 1;
        totalPagesForCompleted = 0;
        window.location.href = 'index.html'; // Перенаправляем после очистки
    }

    window.addEventListener('beforeunload', () => {
        if (tasksUpdateIntervalId) {
            clearInterval(tasksUpdateIntervalId);
        }
    });
</script>
</body>
</html>
